# temp yandex server per october 2020  ssh -i yandex klockvud@84.201.135.182

Часть 1 30-06 ( страница 1)

В джанго в первую очередь надо создать свой проект, командой python manage.py startapp name_of_app
прописать name_of_app в mysite.settings.INSTALLED_APPS
Дальше следует создать базу данных командами <manage.py migragte> для первого запуска.
Дале в models.py следует прописать существующую базу данных для проекта.
После прописывания обьектов, командами  <makemigrations name_of_the_app> создаём базу данных и снова
<manage.py migragte> для сохранения данных. При этом в migrations будет создан initial.py который кратко описывает вашу модель

По постфиксу /admin будет сайт admin. Чтобы на него зайти, необходимо зарегестрироваться ( создав superuser )
Теперь в панельки admin мы можем менять то, как выглядит наша страничка  адмнинистрирования.

Помимо этого мы можем работать через <python manage.py shell> для доавления или удаления или проверки обьектов в датабазе,
пример комманд:
    from django.contrib.auth.models import User
    from blog.models import Post
    post = Post(title = ' lol ' , slug = 'another' , body= 'bodyy', author =User.objects.get(username = 'admin' )) # создали
    post.save() # созранили
    # или сделали
    Post.objects.create(title='One more post', slug='one-more-post', body='Post body.', author=User.objects.get(username = 'admin' ))  # 2 в 1
    Post.objects.all() # можно посмотреть все обьекты
    Post.objects.filter(publish__year=2020) # отфильтровать
    Post.objects.filter(publish__year=2020).exclude(title__startswith='Why')  # отфильтровать с искдлючением
    Post.objects.order_by('title') # отсортировать '-title' в обратном порядке
    post = Post.objects.get(id=1)
    post.delete()  # удалить
    User.objects.all()[0].blog_posts # получиь все посты в блоге юзера с айди 0. Работает благодаря обратному имени related_name = 'blog_posts'
Вся работа с моделью идёт отдельно работы с view. Всё что отображается на сайте находится в view.
Теперь, создав view, заполним его методами. В view мы можем докинуть пару полей на страницу, чтобы потом их там забрать,
помимо этого в urls добавляем наши ссылки. Папка Static видна и в неё можно класть постоянные штуки через {%load static}.
И потом обращаться через {% static 'css/blog.css' %}



В одном файле будет {% block some_name %}My Blog1{% endblock %} и так же пометка, что этот файл Расширяет
{% extends "blog/base.html" %} другой файл. И если в другом фалйе юудет те же {% block some_name %}{% endblock %},
то они внутри будут заменены на надпись из первого файла.
{% block title %}{{ post.title }}{% endblock %} вот такая запись в расширяющем другие файле будет означать
Вставить Значение post.tile, который мы передали ещё в view.py

Если информации слишком много, тогда следует добавить Пагинацию. Она добавляется следующим образом ->
Передаём в .GET. 'page': page - номер страницы и принимаем его в views.py . Потом добавляем
 {% include "my_pagination.html" with page=posts %}, заменяя page на posts.

 Если мы не любим функции, то можно наследоваться от класса ListView и в итоге всё будет +- так же.

https://www.youtube.com/watch?v=WTXPLwrK398&list=PLF-NY6ldwAWrb6nQcPL21XX_-AmivFAYq&index=7

Часть 2 03-07 ( страница 40 )

Отправка форм -> подключаем библиотеку и работаем теперь с ней в фалйе views прописано как мы проверяем полученный
запрос.

Отправка почты происходит через smtp сервер с либой джанго (точно такой же как и питон).

Чтобы перейти на страницу с отправкой <a href="{% url 'blog:post_share' post.id %}">  (  {% url %} template
tag provided by Django ) вызываем функцию, она создаёт нам пустую форму и кладёт на страницу share.html .
Там эта форма отправляется post запросом на ту же страницу. Так же используется CSFR токен для обезопашивания.

Добавление комментариев. Создадим класс в модели, добавим её в административную панель. Создадим класс других формачек,
добавим их на страницу и таким же образом посылая POST запросы будем их обробатывать.

Часть 3 03-07 страница 67

Добавление своих собственных тегов. Чтобы быть ещё круче, можно добавить свои теги (вставки в html). Создадим рядом с
template -> templatetags/blog_tags.py и в нём register = template.Library(), что обозначает, что это библиотека тегов

Теперь, зарегистрируем

@register.simple_tag()
def total_posts(posts):  # name of tag
    return Post.published.count()

Самый простой тег, которому передаётся параметр posts (просто так {% total_posts 42 %} ) и который возвращает стрчоку.
Рядом с ним можно оформить тег inclusion_tag('blog/post/latest.html'), который включает в себя latest.html и расширяет его
dict, который передался в return. Таких тегов есть достаточно много и использовать их нужно. Добавление тега в код сопровождается
добавлением  {% load blog_tags %} почти явного инклюда этого самого файла.

Добавление своих собственных фильтров к тегам. Фильтр с парамтерами выглядит вот так  {{ variable|my_
filter:"foo" }}. Зарегестрируем тег в темплейтахtag и инклюдим его. Теперь наш фильтр делает из текста markdown текст
используем его в наших блогах.

Добавим sitemap, сайтмап это штука, чтобы поисковики легче ориентировались в нашем сайте. В ней в формате xml
указывается как часто меняется страница, относительно других страниц и насколько важная информация на этой странице.
Для этого в настройках добовляем приложение, в нашем приложении добавляем sitemaps, который будет отвечать за
генерацию и указываем то, какие обьекты будут итерироваться для сайтпамы. Далее добовляем ссылку в url и теперь мы можем перейти по
xxx/sitemap.xml чтобы посмотреть, что же у нас получилось. Так же стоит указывать домен по ссылке xxx/admin/site/site.

Подключение на сервер:
Закидываем проект. Меняем debug = false. Добавляем айпишник в allowed host. Теперь запуск можно сделать через
runserver 0.0.0.0:8000 -> текущий айпишник в глобаке. Но сервер от джанго достаточно межденный, поэтому настроим
ngix -> более быстрый сервер и он будет общаться с джанго через wsgi. (pip install gunicorn ( библа для соединения через
wsgi)
Далее запустим сервер над папкой проекта gunicorn --bind 0.0.0.0:8000 mysite.wsgi .
Он переодически отключается, для того, чтобы он так не делал, воспользуемся утилитой на линуксе : systemd .
Она будет запускать наше приложение, когда то отключится.
sudo nano /etc/systemd/system/gunicorn.service - создадим файл,  и в него запишем юнит ( штука которая будет открывать)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[Unit]
# это текстовое описание юнита, пояснение для разработчика
Description=gunicorn daemon

# при старте операционной системы запускать процесс только после того,
# как операционная система загрузится и настроит подключение к сети
After=network.target

[Service]
# от чьего имени запускать процесс:
# укажите имя, под которым вы подключались к серверу
User=<имя-пользователя-в-системе>

# адрес к директории, где установлен Gunicorn
WorkingDirectory=/home/<имя-пользователя-в-системе>/<директория-проекта>

# команду, которую вы запускали руками, теперь будет запускать systemd:
# в указанной директории будет выполнена команда bind
ExecStart=<путь-до-gunicorn-в-виртуальном-окружении> \
          --bind 127.0.0.1:8000 \
          <имя-проекта>.wsgi:application # файл запуска приложения

[Install]
WantedBy=multi-user.target # группировка юнитов

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

команда which gunicorn говорит путь до гана.
Теперь запускаем его через sudo systemctl start gunicorn # запустить юнит
и проверяем через  systemctl status gunicorn.service. Теперь наша команда выполняется постояно

Далее необходимо настроить ngix сервер, он будет перенаправлять запросы с порта 80 (дефолтный https)
на 8000. А так же возвращать статик файлы сразу, а динамику перенаправлять на Django.
* установим егo sudo apt install nginx -y . Далее добавим фаервол
sudo ufw allow 'Nginx Full' # разрешит принимать запросы на порты — 80 и 443: на них по умолчанию приходят запросы по http и https.
sudo ufw allow OpenSSH # открывает порт 22 — это стандартный порт для соединения по ssh. Если этот порт не открыть, то после запуска файрвола доступ по ssh будет заблокирован: замок защёлкнулся, а ключ остался внутри.
sudo ufw enable # запустили фаервол
sudo systemctl start nginx  # запустили ngix

Теперь надо поработать со статикой, возьмём и добавим
STATIC_URL = '/static/' # префикс для url
STATIC_ROOT = os.path.join(BASE_DIR, 'static/') # папка, в которой будет лежать статика
После вызовем
  python manage.py collectstatic, он соберёт всю статику в одном месте.
 Теперь настроим ngix чтобы тот работал с джанго
 sudo nano /etc/nginx/sites-enabled/default
 добавить в конец
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # инструкции для nginx
server {
    # следи за портом 80 на сервере с IP <ваш-ip>
    listen 80;
    server_name <ваш-ip>;

    # если в адресе запроса есть аргумент '/static/' - верни файл из директории static/
      location /static {
        root /path/to/your/mysite/django_blog/;  # расположение статики (в джанго блоге лежит статика)
    }
    # любой другой запрос передай серверу Gunicorn
    location / {
        include proxy_params;
        # передавать запросы нужно на внутренний IP на порт 8000
        proxy_pass http://127.0.0.1:8000;
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Теперь добавим домен. На сайте домена укажем Record A переодресацию на наш айпи
server name = gigglingpenguin.me
и в allowed host gigglingpenguin.me
перезагружаем всё что видем ngix и gunicorn
И теперь по нашему домену доступен наш сайт.

Далее настроим https. Чтобы это сделать, нам нужен ssl сертификат, который закрепит за нашим доменом наш ip.
Сайт https://letsencrypt.org/getting-started/ предоставляет бесплатные ssl ертифекаты при помощи
certbot https://certbot.eff.org/lets-encrypt/ubuntubionic-nginx -> там же у нас фулл установка
sudo certbot --nginx и ответы  (a, n, /enter, 2)

